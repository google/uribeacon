# =============================================================================
# Copyright 2015 Google Inc. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# =============================================================================

# =============================================================================
# URIBEACON v2 for Bluegiga BLED112 dongle
# Date: 2015:01:29-14:54
# =============================================================================

# 
# CONSTANTS
#

# Time constants
const TIME_30S = $f0000 
const TIME_10S = $50000
const TIME_2S = $10000 
# Adv Timer Constants
const TIME_100mS = 160 

# Flash constants
const GUARD_ON = $aa
const GUARD_OFF = $ff

# GATT Error codes
const rc_success = 0 
const rc_write_not_permitted = $03
const rc_insufficient_authorization = $08
const rc_invalid_attribute_length = $0d

#
# GLOBAL VARIABLES
# 

# Flash Memory
dim flash_read_len
dim flash_read_data(1)

# URI state Storage
dim lockstate(1)
dim lock(16)
dim uridata(20)
dim urisize(1)
dim uriflags(1)
dim advtxpowerlevels(4)
dim txpowermode(1)
dim beaconperiod(2)
dim reset(1)
dim radiotxpowerlevels(4)

# ADVertizement data
dim advUrlData(31)
dim advConfData(31)
dim advConfSrData(31)

# GATT variables during READs
dim gatt_read_data(20)
dim gatt_read_len
dim period
dim timer_period

# GATT Return Code
dim rc

# TTY Interaction - variables
dim result2
dim data2
dim data_size2

# 
# PROCEDURES
#

# Initialize the beacon state variables
procedure init_uribeacon_state()
  # Init guard byte
  flash_read_data(0:1) = GUARD_ON

  # Init config params
  lockstate(0:1) = 0      # unlocked
  memset(lock(0), 0, 16)  # lock value initally all zeros
     
  # Init Flags default
  uriflags(0:1) = 0 

  # Init the tx power mode
  txpowermode(0:1) = 1 # low power

  # Initialize the URL to uribeacon.org
  urisize(0:1) = 11
  uridata(0:11) = "\x02uribeacon\x08"

  # Init Beacon Period
  period = 1000
  beaconperiod(0:1) =  period - (256 * (period/256))
  beaconperiod(1:1) =  period / 256

  # Init the adv power levels
  advtxpowerlevels(0:4) = "\xe8\xf0\xf8\x02"

  # Init the radio power levels
  radiotxpowerlevels(0:4) = "\x00\x05\x0a\x0f"
end

# Update the Uribeacon ADV packet from beacon state
procedure init_adv_from_state()
  # Adv Flags
  advUrlData(11:1) = uriflags(0:1)

  # Adv TxPower
  advUrlData(12:1) = advtxpowerlevels(txpowermode(0:1):1)
  call hardware_set_txpower( radiotxpowerlevels(txpowermode(0:1):1) )

  # Adv Uri Data
  memcpy(advUrlData(13), uridata(0), urisize(0:1)) 

  # Update service data length
  advUrlData(7:1) = 5 + urisize(0:1)  # update the new service data length
end

# Sets the ADV packet to the UriBeacon URL packet
procedure set_uribeacon_url_mode() 
  # Stop previous adv
  call gap_set_mode(0, 0)
  # remove scan response
  call gap_set_adv_data(1, 0, 0)

   # Flags = LE General Discovery, single mode device (02 01 06)
   advUrlData(0:1)  = 2   # Length
   advUrlData(1:1)  = $01 # AD Type Flags
   advUrlData(2:1)  = $06 # $06=No EDR, general_discoverable,  [$04=No-EDR]

   # UriBeacon Service UUID 
   advUrlData(3:1)  = 3   # Length
   advUrlData(4:1)  = $03 # AD Type Service UUID
   advUrlData(5:1)  = $D8 # 16-bit UUID LSB
   advUrlData(6:1)  = $FE # 16-bit UUID MSB

   # UriBeacon Service Data
   length = 5 + sizeof(uridata)
   advUrlData(7:1)  = 16  # Length
   advUrlData(8:1)  = $16 # AD Type Service Data
   advUrlData(9:1)  = $D8 # 16-bit UUID LSB
   advUrlData(10:1) = $FE # 16-bit UUID MSB

   call init_adv_from_state() # generate content of UriBeacon in ADV packet


   # Only establish a new beacon if period !=0
   period = 256 * beaconperiod(1:1) + beaconperiod(0:1)
   if period !=0 then
   # Adv min period read from characteristic, max = min + (min / 10). Use all three adv channels.
     timer_period = (period * 16) / 10 # converted to timer value equivalent to period mS
     call gap_set_adv_parameters(timer_period, timer_period + (timer_period / 10), 7)

     # Set Adv URL Data
     call gap_set_adv_data(0, 31, advUrlData(0:31))

     #set to advertising mode - with user data (not connectable)
     call gap_set_mode(gap_user_data, gap_non_connectable)
   end if
end

# Sets the ADV packet to be the Uribeacon Config packet
procedure set_uribeacon_config_mode()
   #Stop previous adv
   call gap_set_mode(0, 0)

   # SET ADV PARAMS

   # Flags = General Discovery, single mode device (02 01 06)
   advConfData(0:1)  = 2     # Length
   advConfData(1:1)  = $01   # AD Flags
   advConfData(2:1)  = $06   # $06=No EDR, general_discoverable [$04=No-EDR]

   # UriBeacon Service UUID 
   advConfData(3:1)   = 17   # Length
   advConfData(4:1)   = $07  # AD Service UUID (128 bits)
   advConfData(5:16)  = "\xd8\x81\xc9\x1a\xb9\x99\x96\xab\xba\x40\x86\x87\x80\x20\x0c\xee"

   # Transmit Power
   advConfData(21:1)   = 2   # Length
   advConfData(22:1)   = $0A # AD Transmit Power
   advConfData(23:1)   = advtxpowerlevels(2:1)         # Set MEDIUM Power in Adv pkt
   call hardware_set_txpower(radiotxpowerlevels(2:1))  # Set MEDIUM Power in Radio

   # SET SCAN RESPONSE PARAMS

   # Flags = LE General Discovery, single mode device (02 01 06)
   advConfSrData(0:1)  = 2   # Length
   advConfSrData(1:1)  = $01 # AD Flags
   advConfSrData(2:1)  = $06 # 06=connectable 04=non-connectable

   # Adervtised Name= "Change Uri"
   advConfSrData(3:1)  = 11  # Length
   advConfSrData(4:1)  = $09 # AD Full Name
   advConfSrData(5:15) = "Change Uri" 

   # Adv default period = 1000ms - (1000 + 100mS). Use all three adv channels.
   timer_period = (1000 * 16) / 10 # converted to timer value equivalent to period mS
   call gap_set_adv_parameters(timer_period, timer_period + TIME_100mS, 7)

   # Set Adv Config Data
   call gap_set_adv_data(0, 24, advConfData(0:24))
   # Set Adv Scan Response Config Data
   call gap_set_adv_data(1, 20, advConfSrData(0:20))

   #set to advertising mode - with user data
   call gap_set_mode(gap_user_data, gap_undirected_connectable)
end

# 
# Non Volatile Memory (Flash) Storage Read/Write
#

procedure read_state_from_flash()
   # READS: aligning reads with 16-byte boundaries
   call flash_read_data(0, 1)(flash_read_len, flash_read_data(0:1))
   call flash_read_data(16, 1)(flash_read_len, lockstate(0:1))
   call flash_read_data(32, 16)(flash_read_len, lock(0:16))
   call flash_read_data(48, 20)(flash_read_len, uridata(0:20))
   call flash_read_data(80, 1)(flash_read_len, urisize(0:1))
   call flash_read_data(96, 1)(flash_read_len, uriflags(0:1))
   call flash_read_data(112, 4)(flash_read_len, advtxpowerlevels(0:4))
   call flash_read_data(128, 1)(flash_read_len, txpowermode(0:1))
   call flash_read_data(144, 2)(flash_read_len, beaconperiod(0:2))
   call flash_read_data(160, 1)(flash_read_len, reset(0:1))
   call flash_read_data(176, 4)(flash_read_len, radiotxpowerlevels(0:4))
end

procedure write_state_to_flash()
   call flash_erase_page(0)
   # WRITES: aligning writes with 16-byte boundaries
   call flash_write_data(0, 1, flash_read_data(0:1))
   call flash_write_data(16, 1, lockstate(0:1))
   call flash_write_data(32, 16, lock(0:16))
   call flash_write_data(48, 20, uridata(0:20))
   call flash_write_data(80, 1, urisize(0:1))
   call flash_write_data(96, 1, uriflags(0:1))
   call flash_write_data(112, 4, advtxpowerlevels(0:4))
   call flash_write_data(128, 1, txpowermode(0:1))
   call flash_write_data(144, 2, beaconperiod(0:2))
   call flash_write_data(160, 1, reset(0:1))
   call flash_write_data(176, 4, radiotxpowerlevels(0:4))
end

#
# EVENT HANDLERS
#

# HANDLER: WRITE UriBeacon Service Charascteristic 
event attributes_value(connection, reason, handle, offset, value_len, value_data)
  # Default: return succes code
  rc = rc_success
  # CHECK LOCK STATE
  if (lockstate(0:1) = 1) then 
    # URIBEACON IS LOCKED
    if handle = uri_unlock
      if value_len = 16 then
        if memcmp(value_data(0), lock(0), 16) then
          # UNLOCK BEACON
          lockstate(0:1) = 0
        else # ERROR: WRONG PASSCODE
          rc = rc_insufficient_authorization
        end if
      else # ERROR: BAD PASSWORD LENGTH
        rc = rc_invalid_attribute_length
      end if
    else # ERROR: TRYING TO MODIFY LOCKED BEACON
      # Locked, Error calling any other charasctistics except uri_unlock
      rc = rc_insufficient_authorization
    end if
  else 
    # URIBEACON IS UNLOCKED
    if handle = uri_lock && value_len = 16 then
      # store new key
      memcpy(lock(0), value_data(0), value_len)
      # change lock state
      lockstate(0:1) = 1
    else
      # URI DATA
      if ((handle = uri_data) && (value_len <= 18))  then
        urisize(0:1) = value_len
        memcpy(uridata(0), value_data(0), value_len)
      else
        # FLAGS
        if handle = uri_flags && value_len = 1 then
          uriflags(0:1) = value_data(0:1)
        else 
          # ADV TXPOWER LEVELS
          if handle = uri_adv_txpower_levels && value_len = 4 then
            memcpy(advtxpowerlevels(0), value_data(0), value_len)
          else            
            # TXPOWER MODE
            if handle = uri_txpower_mode && value_len = 1 then
              if value_data(0:1) >= 0 && value_data(0:1) <= 3 then
                txpowermode(0:1) = value_data(0:1)
              else
                rc = rc_write_not_permitted
              end if
            else
              # BEACON PERIOD
              if handle = uri_beacon_period && value_len = 2 then
                memcpy(beaconperiod(0), value_data(0), value_len)
                period = 256 * beaconperiod(1:1) + beaconperiod(0:1)
                if period < 100 && period > 0 then
                  beaconperiod(1:1) = 0
                  beaconperiod(0:1) = 100
                  period = 100
                end if 
              else
                # RESET
                if handle = uri_reset && value_len = 1 then
                  reset(0:1) = value_data(0:1)
                  call init_uribeacon_state()
                else
                  # RADIO TXPOWER LEVELS
                  if handle = uri_radio_txpower_levels && value_len = 4 then
                    memcpy(radiotxpowerlevels(0), value_data(0), value_len)
                  else
                    # UNLOCK
                    if handle = uri_unlock && value_len = 16 then
                      rc = rc_success
                    else
                      # ERROR = bad attribute length as the system already detects invalid characteristics
                      rc = rc_invalid_attribute_length
                    end if # unlock when already unlocked
                  end if # radio txpower levels
                end if # reset
              end if # beacon period
            end if # txpower mode
          end if # adv txpower levels
        end if # flags
      end if # data
    end if # lock
  end if # unlocked
  # Send the GATT WRITE response back to client
  call attributes_user_write_response(connection, rc)
end

# HANDLER: READ UriBeacon Service Charascteristic
event attributes_user_read_request(connection, handle, offset, maxsize)
  # Default return code
  rc = rc_success

  # LOCK STATE
  if handle = uri_lockstate then
    gatt_read_len = 1
    gatt_read_data(0:1) = lockstate(0:1)
  else
    # URI DATA
    if handle = uri_data then
      gatt_read_len = urisize(0:1)
      memcpy(gatt_read_data(0), uridata(0), gatt_read_len)
    else
      # FLAGS
      if handle = uri_flags then
        gatt_read_len = 1
        gatt_read_data(0:1) = uriflags(0:1) 
      else 
        # ADV TXPOWER LEVELS
        if handle = uri_adv_txpower_levels then
          gatt_read_len = 4
          memcpy(gatt_read_data(0), advtxpowerlevels(0), gatt_read_len)
        else
          # TXPOWER MODE
          if handle = uri_txpower_mode then
            gatt_read_len = 1
            gatt_read_data(0:1) = txpowermode(0:1)
          else
            # BEACON PERIOD
            if handle = uri_beacon_period then
              gatt_read_len = 2
              memcpy(gatt_read_data(0), beaconperiod(0), gatt_read_len)
            else
              # RESET
              if handle = uri_reset then
                gatt_read_len = 1
                gatt_read_data(0:1) = reset(0:1)
              else
                # RADIO TXPOWER LEVELS
                if handle = uri_radio_txpower_levels then
                  gatt_read_len = 4
                  memcpy(gatt_read_data(0), radiotxpowerlevels(0), gatt_read_len)
                else
                  # ERROR = bad attribute length as the system already detects invalid characteristics
                  rc = rc_invalid_attribute_length
                end if # radio txpower levels
              end if # reset
            end if # beacon period
          end if # txpower mode
        end if # adv txpower levels
      end if # flags
    end if # data
  end if # lockstate
  # Send the GATT READ response back to client
  call attributes_user_read_response(connection, rc, gatt_read_len, gatt_read_data(0:gatt_read_len))
end

# HANDLER GATT Disconnection 
event connection_disconnected(handle, result)
  call set_uribeacon_url_mode()
  call write_state_to_flash()
end

# HANDLER USB Serial Input
event system_endpoint_watermark_rx(endpoint, data_len)
  # DFU BOOT
  call system_endpoint_rx(endpoint, data_len)(result2, data_size2, data2)
  if data2 = $30 then #ascii 0 is 0x30
    call system_endpoint_tx(3, data_size2, data2)
    call system_endpoint_tx(3, 47, " <--- REBOOT 0 entered: rebooting in dfu mode\n\r\n\r")
    call flash_erase_page(0)
    call system_reset(1)
  else 
    #DEBUG Reads
    if data2 = $31  then
      call system_endpoint_tx(3, 11, "DEBUG 1\n\r\n\r")
      call flash_read_data(0, 1)(flash_read_len, flash_read_data(0:1))
    else
      call system_endpoint_tx(3, data_size2, data2)
      call system_endpoint_tx(3, 45, " <--- enter ASCII 0 to reboot in dfu mode\n\r\n\r")
    end if
  end if
end

# HANDLER soft timer 1 fired
event hardware_soft_timer(handle)
  if handle = 1 then
    call set_uribeacon_url_mode()
  end if
end

# HANDLER: MAIN: SYSTEM BOOT 
event system_boot(major, minor, patch, build, ll_version, protocol_version, hw)
  # Enable watermark for USB interface to detect incoming data from USB
  # This is needed to boot the device into DFU mode for firmware update
  call system_endpoint_set_watermarks(3, 1, 0)
 
  call flash_read_data(0, 1)(flash_read_len, flash_read_data(0:1))
  if flash_read_data(0:1) = GUARD_OFF then
    # GUARD_OFF: Init beacon state to default state
    # write it all to flash and set the guard byte to ON
    call init_uribeacon_state()
    call write_state_to_flash()
   else
     if flash_read_data(0:1) = GUARD_ON then 
       # GUARD ON: so init beacon state from flash
       call read_state_from_flash()
     else
       # FLASH NOT IN A VALID STATE
       call system_endpoint_tx(3, 25, "ERR: PLEASE REFLASH! \n\r\n\r")
     end if
   end if
   # Set advertisement data to ADV config
   call set_uribeacon_config_mode()
   # single shot timer handle=1, configuration ADV for 30s, before Uri ADV
   call hardware_set_soft_timer(TIME_30S, 1, 1)
end

